<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="styles.css" />
    <script type="text/javascript" src="common.js"></script>
    <script
      type="text/javascript"
      src="102 binary tree level order traversal.js"
    ></script>
    <script type="text/javascript">
      document.addEventListener("DOMContentLoaded", function() {
        //document.getElementById("result").innerHTML = 101;
      });
    </script>
    <title>102. Binary Tree Level Order Traversal</title>
  </head>
  <body>
    <main>
      <h1>102. Binary Tree Level Order Traversal</h1>
      <section>
        <h2>Description</h2>
        <div>
          <p>
            Given a binary tree, return the <i>level order</i> traversal of its
            nodes' values. (ie, from left to right, level by level).
          </p>

          <p>
            For example:<br />
            Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br />
          </p>
          <pre>
    3
   / \
  9  20
    /  \
   15   7
</pre
          >
          <p></p>
          <p>return its level order traversal as:<br /></p>
          <pre>
[
  [3],
  [9,20],
  [15,7]
]
</pre
          >
          <p></p>
        </div>
      </section>
      <section>
        <h2>My Solution</h2>
        <!-- <h3>Example Testcase</h3>
        <pre> Example goes here! </pre> -->
        <h3>Analysis</h3>
        <p>
          This is basically just breadth-first search. The only difference here
          is that we need to keep track of which nodes are in which level so
          it's not as simple as just regular BFS. To start, we create a queue
          for nodes we discover as we traverse the tree and enqueue the root. We
          then add the root to the list of nodes on the current level. Then
          enqueue the root's children and add the list of nodes at that level to
          the main list of lists of nodes. We then "move" to the next level and
          repeat this process until the queue is empty.
        </p>
        <p>
          We visit every node in the tree exactly once so the running time is
          just O(n) where n is the number of nodes.
        </p>
      </section>
    </main>
  </body>
</html>
